Коротко: мы свели «геометрию» и «время» к одной системе отсчёта и убрали фазовый сдвиг. Конкретно сделали три вещи.

1. Привели сетку тиков к той же нулевой фазе, что и стрелки
• Проблема: тики рисовались со сдвигом на referenceHour (18:00) и в итоге тик 0 оказывался не на 18:00 (вправо), а на 24:00 (вниз). Это давало постоянный фазовый сдвиг относительно угла стрелки.
• Исправление: в TicksView угол тика считаем просто как i * degreesPerTick, без вычитания referenceHour. Теперь 18:00 = 0° вправо и для стрелок, и для ticdots.

2. Согласовали знак поворота контейнера со знаком угла жеста
• Особенность SwiftUI: .rotationEffect(+) крутит ПРОТИВ часовой, а экранная геометрия (atan2 с осью Y вниз) даёт положительное «по часовой». Это вызывало инверсию ощущений и могло провоцировать «сползания».
• Исправление: rotationAngle в ViewModel сделали отрицательным от tickIndex:
rotationAngle = -Double(tickIndex) * step
и при расчёте ticksDelta из жеста инвертировали знак (−rotationTurns*totalTicks), чтобы «пальцем по часовой → контейнер по часовой».

3. Убрали фазовый сдвиг в Режиме 2, фиксируя время на сетке 15 минут
• Проблема: при входе в Режим 2 стрелка оставалась на «сырых» минутах (например, 07), то есть не на центре тика. Даже при идеальном вращении на кратные 3.75° стрелка никогда бы не попала в центры точек.
• Исправление: при входе в Режим 2 frozenTime округляем до ближайшей четверти часа (0/15/30/45). Это гарантирует, что маркер стрелки стартует ровно в центре ближайшего ticdot, и при каждом шаге tickIndex дальше попадает точно в центры.

Почему теперь нет рассинхрона:
• Нулевая фаза совпадает (18:00 = 0° вправо и у стрелок, и у тиков).
• Шаг поворота контейнера кратен шагу сетки (3.75°).
• Стартовая фаза стрелки в Режиме 2 кратна 15 минутам, значит маркер всегда «сидит» на центрах ticdots при любой последовательности оборотов и инерции.

# Логика вращения циферблата ClockW3

## Два независимых режима работы (исключают друг друга)

### Режим 1: ТОЧНОЕ ВРЕМЯ (по умолчанию)
**Активен при запуске и после нажатия центральной кнопки**

**Характеристики:**
- Стрелки показывают точное текущее время
- Ежеминутная автоматическая синхронизация положения стрелок
- НЕТ драга
- НЕТ инерции
- НЕТ прилипания/snap
- НЕТ хаптики
- НЕТ магнитов
- Просто точное время, ничего больше

**Деактивация:**
- При начале драга пользователем → переход в Режим 2

---

### Режим 2: СВОБОДНОЕ ВРАЩЕНИЕ (спиннер/машина времени)
**Активируется началом драга (любое вращение пользователем)**

**Характеристики:**
- Контейнер (стрелки, цифры, точки, подписи) вращается в любую сторону
- Работает как спиннер
- Инерция ✅
- Прилипание к тикам (snap) ✅
- Хаптика ✅
- Магниты ✅
- Ежеминутная синхронизация времени **ОТКЛЮЧЕНА**

**Назначение:**
- "Машина времени" - посмотреть время в другом часовом поясе
- Соотнести с локальным временем
- Установить напоминание (данные считываются из позиции стрелок)
- Preview напоминания отображает время по позиции стрелок

**Деактивация:**
- Нажатие центральной кнопки → возврат в Режим 1 (точное время)

---

## Важные правила

1. **Два режима ИСКЛЮЧАЮТ друг друга** - не могут быть активны одновременно
2. **Режим 1 = пассивный** (только синхронизация времени)
3. **Режим 2 = активный** (пользовательское управление)
4. **Центральная кнопка = RESET** → всегда возвращает в Режим 1

---

## Система координат циферблата

```
        12:00 (270° или -90°)
              ↑
              |
6:00 ← ─ ─ ─ + ─ ─ ─ → 18:00 (0°)
(180°)        |
              ↓
           00:00 (90°)
```

- 0° = 18:00 (справа)
- 90° = 00:00 (внизу)  
- 180° = 6:00 (слева)
- 270° (-90°) = 12:00 (вверху)

---

## Техническая реализация

### Режим 1: Точное время
```swift
// Timer каждую минуту
timer = Timer.scheduledTimer(withTimeInterval: 60.0, repeats: true) { _ in
    self.currentTime = Date()  // Обновляем время
    // Стрелки автоматически пересчитываются от currentTime
}
```

### Режим 2: Свободное вращение
```swift
// При начале драга
func onDragStart() {
    timer?.invalidate()  // ОТКЛЮЧАЕМ синхронизацию времени
    isDragging = true
    // Включаем физику: инерция, snap, хаптика
}

// Стрелки вычисляются от offsetTime
var offsetTime: Date {
    currentTime.addingTimeInterval(Double(tickIndex * 15 * 60))
}

// При нажатии центральной кнопки
func resetRotation() {
    tickIndex = 0  // Сброс в ноль
    timer = startTimer()  // ВКЛЮЧАЕМ обратно синхронизацию
}
```

---

## Что НЕ НАДО делать

❌ Смешивать режимы (синхронизация + драг одновременно)
❌ Применять snap/магниты в Режиме 1
❌ Продолжать синхронизацию времени в Режиме 2
❌ Накапливать ошибки через `angle += delta` (только `atan2`)
❌ Использовать Float (только Double для углов)

---

## Что НАДО делать

✅ Чистое разделение режимов (взаимоисключающие состояния)
✅ Timer работает ТОЛЬКО в Режиме 1
✅ Физика работает ТОЛЬКО в Режиме 2
✅ Центральная кнопка = гарантированный возврат в Режим 1
✅ Использовать `atan2` для нормализации углов
✅ Использовать Double для всех угловых вычислений
✅ Считать углы от времени/позиции, а не накапливать

---

**Дата создания:** $(date)
**Версия:** 1.0
